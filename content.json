{"meta":{"title":"CnNull","subtitle":null,"description":null,"author":"TeAmo'Y","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JAVA数组","slug":"JAVA数组","date":"2019-06-03T14:33:52.519Z","updated":"2019-06-03T14:48:49.259Z","comments":true,"path":"2019/06/03/JAVA数组/","link":"","permalink":"http://yoursite.com/2019/06/03/JAVA数组/","excerpt":"数组的定义 数组是引用数据类型。（引用数据类型还有类、数组、接口）","text":"数组的定义 数组是引用数据类型。（引用数据类型还有类、数组、接口） 动态定义定义格式：数据类型 [] 数组名 = new 数据类型[数组长度]；1int [] arr = new int [3]； 数组定义格式分析:1.数据类型 : 当前数组容器中,可以存放什么类型的数据2.[] : 表示是一个数组,一维数组3.数组名: 名字,符合标识符的规范4.new : 新建,给数组在内存中开辟一块空间,用于存储数据5.数据类型: 与前面的数据类型保持一致6.[数组长度]:数组长度必须给出,确定在内存中给数组开辟的空间是多大 123456789int[] arr = new int[3];//[I@15db9742 : arr数组变量打印出的结果/*[ : 表示是一个数组,并且是一个一维数组I : 数组的容器中,存放的数据类型为int类型,将int的首字母大写@ : 表示分隔符,分离前后15db9742 : 一个十六进制数(逢16进1,到10 (a),11(b)...15(f)),表示arr数组在内存中的地址值(地址值展示方式是转换成了16进制数,使用hashCode()方法)说明: 数组作为引用数据类型存在,变量值已经不是普通的数值,变量就表示当前数组在内存中的地址(类的变量名也是一样,都是在内存中的地址值)*/ 静态定义当明确知道数组中的内容,可以进行静态定义,静态定义仍然在内存中开辟空间,只不过JVM给的初始值0,还是有,JVM赋完初值后,数组大括号中的数据依次替换到对应的索引位置处 定义方式: 数据类型[] 数组名 = {数据};举例: int[] arr = {2,3,4,7,-2,77};// 数组长度为6 索引: 0索引上的元素值2,依次类推,… 5索引上的元素为77 说明: 大括号中的数据个数,没有限定 1234567891011121314151617181920212223//数组的定义public class ArrDefine&#123; public static void main(String[] args) &#123; // 定义一个int类型的数组,数组的长度为3,动态定义 int[] arr = new int[3]; System.out.println(arr);//[I@15db9742 // 静态的定义 int[] arr1 = &#123;1,2,4,5,-9,77&#125;; System.out.println(arr1);//[I@6d06d69c System.out.println(arr1[4]);// -9 // 动静结合 int[] arr2 = new int[]&#123;1,2,4,5,-9,77&#125;; System.out.println(arr2);//[I@7852e922 System.out.println(arr2[5]);// 77 &#125;&#125; 动态+静态数据类型[] 数组名 = new 数据类型[不能写长度]{写上数组中的数据};举例: int[] arr = new int[]{6,7,8}; 数组中元素的获取12int[] arr = new int[3];// 索引 0-2//arr数组,里面能存储3个int类型的元素 索引: index,所有类型的数组,都具有索引索引就表示,在数组中,每个元素在数组中的房间号,与数组的内存地址无关 索引都从0开始,到(数组长度-1)结束(数组长度：leng-th)如何通过索引获取到对应的元素?数组名[索引];arr[0];arr[1];arr[2];代码：123456789101112131415161718// 获取数组中的元素public class ArrGet1 &#123; public static void main(String[] args) &#123; // 定义一个int类型的数组,长度为3 int[] arr = new int[3];// 索引 0-2 System.out.println(arr); // 获取数组中的元素,通过索引的方式 int x = arr[0]; int y = arr[1]; int z = arr[2]; System.out.println(x); System.out.println(y); System.out.println(z); &#125;&#125; 数组内存图说明: 数组中的默认初值(默认值JVM给进行的赋值)int类型 默认值 0double类型 默认值0.0char 类型 默认值\\u0000 (空,什么都没有)boolean类型 默认值falseString类型 默认值null (空,但是不是什么都没有) 数组的手动赋值 1int[] arr = new int[3];// 索引 0-2 赋值方式: 数组名[索引] = 值;注意: 赋值的时候,要求元素的值与其数据类型一定要对应例如: arr[0] = 5; arr[1] = 8; arr[2] = 5;代码：123456789101112131415161718// 获取数组中的元素public class ArrGet1 &#123; public static void main(String[] args) &#123; // 定义一个int类型的数组,长度为3 int[] arr = new int[3];// 索引 0-2 System.out.println(arr); // 给数组中的元素进行赋值 数组名[索引] = 值; arr[0] = 5; arr[1] = 8; arr[2] = 5; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 数组与内存地址的对应案例每次new都在内存中创建新的地址空间,代码如下:123456789101112131415//数组的内存地址解析public class ArrAddress&#123; public static void main(String[] args) &#123; // i 和 i1 都是内存中的地址值,i和i1在内存中的地址一不一样 int[] i = new int[3]; int[] i1 = new int[3]; boolean b = i == i1;// false System.out.println(i);//[I@15db9742 System.out.println(i1);//[I@6d06d69c System.out.println(b);//false &#125;&#125; 数组地址赋值给B数组案例1234567891011121314151617181920//数组的内存地址解析public class ArrAddress&#123; public static void main(String[] args) &#123; // i 和 i1 都是内存中的地址值,i和i1在内存中的地址一不一样 int[] i = new int[3]; int[] i1 = new int[3]; int[] i2 = new int[6]; i1 = i2;// 将i2在内存中的地址值赋值给i1,现在i1和i2指向内存中的同一块空间 boolean b = i == i1;// false boolean b1 = i1 == i2; //true System.out.println(i);//[I@15db9742 System.out.println(i1);//[I@6d06d69c System.out.println(i2);//[I@6d06d69c System.out.println(b);//false System.out.println(b1);//true &#125;&#125; A数组地址赋值给B数组后,B数组中元素的变化案例12345678910111213141516171819//数组的内存地址解析public class ArrAddress&#123; public static void main(String[] args) &#123; // i 和 i1 都是内存中的地址值,i和i1在内存中的地址一不一样 int[] i = new int[3]; int[] i1 = new int[3]; i1[0] = 5;// i1的0索引元素赋值5 int[] i2 = new int[6]; i2[0] = 9;// i2的0索引元素赋值9 i1 = i2;// 将i2在内存中的地址值赋值给i1,现在i1和i2指向内存中的同一块空间 System.out.println(i);//[I@15db9742 System.out.println(i1);//[I@6d06d69c System.out.println(i2);//[I@6d06d69c System.out.println(i1[0]);// 9 &#125;&#125; 数组中的异常异常: 在代码执行的过程中,发生了一些错误或者是本应该能避免的一些失误 数组索引越界异常数组索引越界发生的场景:数组索引越界: ArrayIndexOutOfBoundsException举例:int[] arr = new int[3];// 索引0-2获取元素 : arr[2];// 获取最大的索引对应的元素 arr[3]; 就会发生数组索引越界(指数组中的索引,超出了最大索引范围) 说明:1.如果代码发生了异常(Exception),那么程序将终止运行2.目前如何控制索引越界? 进行数组元素获取时,索引不要超过(数组的长度-1) 代码：1234567891011121314// Exception 就表示异常public class ArrException&#123; public static void main(String[] args) &#123; int[] arr = new int[3];// 索引0-2/*Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 5 at ArrException.main(ArrException.java:10)*/ int x = arr[5]; System.out.println(x); &#125;&#125; 数组空指针异常空指针异常: NullPointerException在Java中,所有引用数据类型的默认值为 null (类,数组)举例:int[] arr = null; // 这个数组arr在内存中没有位置,没有开辟空间arr[0]; // 抛出空指针异常 NullPointerException空指针异常发生的场景:当数组定义为null,并且还要获取这个数组中的元素,那么就会抛出空指针异常 说明:1.如果代码发生了异常(Exception),那么程序将终止运行2.目前如何控制空指针? 在获取数组元素之前,先判断一下,数组的值不为null即可 123 if( arr != null)&#123; arr[0]; &#125; 空指针异常代码：1234567891011121314151617181920// 空指针异常public class ArrException2 &#123; public static void main(String[] args) &#123; // 定义一个null类型的数组 int[] arr = null; /* Exception in thread \"main\" java.lang.NullPointerException at ArrException2.main(ArrException2.java:10) */ // System.out.println(arr[0]); // NullPointerException if(arr != null)&#123;// 解决空指针异常的方案,判断数组不为null System.out.println(arr[0]); // NullPointerException &#125; System.out.println(\"控制住了\"); &#125;&#125; null数组与数组中不定义元素的区别123456789101112131415public class ArrException3&#123; public static void main(String[] args) &#123; int[] arr = null;// arr在内存中没有开辟空间,没有内存地址 int[] arr1 = &#123;&#125;;// arr1在内存中有开辟空间,有内存地址,空间中没有任何元素/* Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0 at ArrException3.main(ArrException3.java:10)*/ System.out.println(arr1[0]);// 报错 数组索引越界 // System.out.println(arr[0]);// 空指针异常 &#125;&#125; end","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA for语句","slug":"JAVA for语句嵌套","date":"2019-05-30T15:19:04.360Z","updated":"2019-05-31T15:11:43.666Z","comments":true,"path":"2019/05/30/JAVA for语句嵌套/","link":"","permalink":"http://yoursite.com/2019/05/30/JAVA for语句嵌套/","excerpt":"使用java中的for语句实现一些功能，这里简单介绍for语句的一些使用方法以及使用语法格式。 for循环语句的语法格式","text":"使用java中的for语句实现一些功能，这里简单介绍for语句的一些使用方法以及使用语法格式。 for循环语句的语法格式 for的语法格式for关键字,循环循环: 指同一个逻辑,需要多次执行,使用循环举例: 登录界面,客户姓名,客户密码,姓名和密码都正确,登录成功 如果姓名或密码输入错误了,给你三次机会,这三次机会就可以使用循环来完成这个功能12345for的语法格式:for( 初始化值(定义变量); 判断语句; 变量值的变化(自增或自减))&#123; 多次执行的语句;&#125; 说明1.初始化值 int i = 0;2.判断语句,必须是boolean类型的逻辑,i &lt; 103.变量值的变化i++for(int i = 0; i &lt; 10;i++){// 功能: 能将0-9的整数打印出来 System.out.println(i);}4.只要判断语句为true,那么for循环中的语句就会执行。 for语句实例打印数字5-1：1234567891011// 打印数字5-1public class ForPrintDemo&#123; public static void main(String[] args) &#123; // for 起始值 5 ,判断条件 &gt;=1 , 变化 -- // for循环内部定义的变量 int i = 5; 只能在循环的大括号中使用 for(int i = 5 ; i &gt;= 1 ; i --)&#123; System.out.println(i); &#125; &#125; 计算1+2+3+…+100的和：123456789101112131415161718192021222324/计算1+2+3+...+100的和// 1+2 = 3+3=6+4=10...+100 = 5050public class Print1To100&#123; public static void main(String[] args) &#123; // sum值作为1-100的总和 int sum = 0; //for 起始值1, &lt;=100 , ++ for(int i = 1 ; i &lt;= 100 ; i++)&#123; /* 1 : 0+1 = 1 = sum i = 2 2: sum = 1 + 3 = 3; i = 3 3: sum = 3 + 3 = 6; i = 4 4: sum = 6 + 4 = 10 .... */ sum = sum + i; &#125; System.out.println(sum); &#125;&#125; for循环的嵌套使用嵌套循环概念:每次循环内部的执行逻辑,恰巧又是另外一个循环 for嵌套循环的语法格式12345for(int i = 1 ; i &lt;= 3 ;i ++)&#123; for(int j = 1; j &lt;= 5; j++)&#123; System.out.println(\"教练第\"+i+\"次指令,队员跑第\"+j+\"圈\"); &#125; &#125; for嵌套使用的案例123456789101112131415161718192021222324252627282930313233/* 打印: ***** **** *** ** **//*什么时候使用嵌套for循环1) 如果有逻辑重复执行,想到循环2) 每次循环,循环体,如果还是一个重复的动作,那么循环体内容仍然还是一个循环规律: 一般来说外层循环用来表示循环执行的次数内层循环用来表示每次循环内部需要执行的逻辑次数*/public class XingXingPrint&#123; public static void main(String[] args) &#123;for(int i = 1 ; i &lt;= 5 ; i++)&#123;// 外层循环表示循环次数,一共打印5行星星,因此外层循环5次 /*每次打印星星时,星星变化规律从5个依次减少,最后变成1个怎么由5变到1,让j=i*/for(int j = i ; j &lt;=5; j++)&#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; &#125;&#125; 使用for循环语句写出乘法表12345678910111213141516171819202122232425public class J2 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;=9; i++) &#123; for (int j = 1; j &lt;=i; j++) &#123; System.out.print(j+\"×\"+i+\"=\"+i*j+\" \"); &#125; System.out.println(); &#125; &#125;&#125;d:\\Desktop&gt;java J21×1=11×2=2 2×2=41×3=3 2×3=6 3×3=91×4=4 2×4=8 3×4=12 4×4=161×5=5 2×5=10 3×5=15 4×5=20 5×5=251×6=6 2×6=12 3×6=18 4×6=24 5×6=30 6×6=361×7=7 2×7=14 3×7=21 4×7=28 5×7=35 6×7=42 7×7=491×8=8 2×8=16 3×8=24 4×8=32 5×8=40 6×8=48 7×8=56 8×8=641×9=9 2×9=18 3×9=27 4×9=36 5×9=45 6×9=54 7×9=63 8×9=72 9×9=81","categories":[],"tags":[]},{"title":"你好，HEXO","slug":"你好，HEXO","date":"2019-05-26T08:22:04.000Z","updated":"2019-05-26T08:22:04.351Z","comments":true,"path":"2019/05/26/你好，HEXO/","link":"","permalink":"http://yoursite.com/2019/05/26/你好，HEXO/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-26T02:35:28.670Z","updated":"2019-05-26T02:35:28.671Z","comments":true,"path":"2019/05/26/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}